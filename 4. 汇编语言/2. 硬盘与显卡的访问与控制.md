# 硬盘与显卡的访问与控制

>   整理自《x86汇编语言 从实模式到保护模式》`第8章 硬盘与显卡的访问与控制`



## 1. 分段、段的汇编地址和段内汇编地址

处理器的工作模式是将内存分成逻辑上的段，指令的获取与数据的访问一律按照**`段地址:偏移地址`**的方式进行。相对应的，一个规范的程序，应当包括代码段、数据段、附加段和栈段。这样一来，段的划分和段与段之间的界限在程序加载到内存之前就已经准备好了。

`NASM`编译器使用汇编指令**`SECTION`**或**`SEGMENT`**来定义段，它的一般格式是:

```assembly
SECTION 段名称
SEGMENT 段名称
```

+   `NASM`编译器不关心段的用途，可能也根本不知道段的用途

+   一旦定义段，后面的内容就都属于该段，除非又出现了另一个段的定义

    >   有时程序并不以段定义语句开始，在这种情况下，这些内容默认地自成一个段。最典型的是，整个程序中都没有段定义语句，此时这个程序自成一个段。

+   `Intel`处理器要求段的内存中的起始物理地址起码是`16`字节对齐的。并且，`汇编语言源程序中定义的各个段，也有对齐方面的要求`。具体的做法是，在段定义中使用**`align=`**子句，用于指定某个SECTION的汇编地址对齐方式。比如说，**`align=16`**就表示段是16字节对齐的，**`align=32`**就表示段是32字节对齐的。

    +   ```assembly
        section data1 align=16
          db 0x55
          
        section data2 align=16
          db 0xaa
          
        section data3 align=16
          0x99
        ```

        +   如果不考虑段的对齐方式，那么段data1的汇编地址是0，段data2的汇编地址是1，段data3的汇编地址是2 。但是，**`由于每个段定义中都包含了要求16字节对齐的子句，data2的汇编地址是0x10，data3的汇编地址是0x20`**

    +   `每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得该段的汇编地址，NASM提供了如下表达式`:

        ```assembly
        section.段名.start
        ```

+   段定义语句还可以包含**`vstart=`**子句。

    +   **如果不包含`vstart=`子句，尽管定义了段，但是引用某个标号时，该标号处的汇编地址依然是从整个程序开头计算的，而不是从段的开头处计算的。**
    +   **如果包含`vstart=`子句，段中定义的标号的汇编地址则是从它所在段的开头计算，而不是从整个程序开头计算。**



## 2. 外围设备及其接口

和处理器打交道的硬件很多，不单单是硬盘，还有显示器、网络设备、扬声器、键盘、鼠标等。所有这些和计算机主机连接的设备，都围绕在主机周围，叫做`外围设备`。这些设备分为两种，一种是输入设备，一种是输出设备，它们也统称**`输入输出设备`**。

输入输出设备与处理器沟通面临两个问题:

+   不可能将所有的I/O接口直接与处理器相连，设备那么多，还有些设备没有发明出来，怎么办？
    +   采用总线技术
+   每个设备的I/O接口都抢着和处理器说话，不发生冲突都难，怎么处理？
    +   使用输入输出控制设备集中器（I/O Controller Hub, ICH）芯片，即`南桥`



### 2.1 I/O端口和端口访问

外围设备和处理器之间的通信是通过相应的I/O接口进行的，具体的说，处理器是通过**`端口（Port）`**来和外围设备打交道的。本质上，**`端口就是一些寄存器，类似于处理器内部的寄存器，不同之处在于，端口寄存器位于I/O接口电路中`**。每一个I/O接口都可能拥有好几个端口，分别用于不同的目的。

**`端口只不过是位于I/O接口上的寄存器，所以，每个端口有自己的数据宽度`**。早期系统中，端口有8位的，也有16位的，之后随着发展，出现了更宽的数据宽度。

端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的，例如，0x00000~0xE0000是真实的物理内存地址，而0xE0001~0xFFFFF是从很多I/O接口那里映射来的，当访问这部分地址时，实际上是在访问I/O接口。

而在另一些计算机系统中（例如Intel处理器），**`端口是独立编址的，不和内存发生关系`**。在这种计算机中，处理器的地址既连接内存，也连接每一个I/O接口。但是处理器还有一个特殊的引脚`M/IO#`，这里`#`表示低电平有效。也就是说，当处理器访问内存时，它会让`M/IO#`引脚呈高电平，这里，和内存相关的电路就会打开；相反，`M/IO#`呈低电平时，则是访问I/O端口。

在Intel系统中，只允许65535个端口存在。因为是**`独立编址`**，所以端口的访问不能使用`MOV`这样的指令，取而代之的是`in`和`out`指令。

+   `in`指令是从端口读，*`in al, dx`*或`in ax, dx`
    +   也就是说，`in`指令的目的操作数必须是寄存器`al`或`ax`，`in`指令的源操作数必须是寄存器`DX`
    +   `in`指令的源操作数如果不使用寄存器，就必须使用立即数。例如`in al, 0xf0`或`in ax, 0x03`，这种指令形式的源操作数只允许一字节，故只能访问0~255号端口
+   `out`指令格式参考`in`指令



### 2.2 通过硬盘控制器端口读扇区数据

8.3.5